<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Дурак: Онлайн и Офлайн</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@500&display=swap');
        
        body {
            background-color: #2e7d32;
            background-image: radial-gradient(#358e39 15%, transparent 16%), radial-gradient(#358e39 15%, transparent 16%);
            background-size: 60px 60px;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            user-select: none;
            touch-action: manipulation;
        }

        /* --- STYLES --- */
        .card {
            width: 70px; height: 105px;
            background-color: white; border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 4px; position: absolute;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer; border: 1px solid #ccc;
        }
        .card:hover { transform: translateY(-10px); z-index: 50 !important; }
        .card.selected { border: 2px solid #3b82f6; transform: translateY(-15px); }
        .suit-red { color: #e53e3e; }
        .suit-black { color: #1a202c; }
        
        @media (min-width: 640px) {
            .card { width: 90px; height: 135px; padding: 6px; }
        }

        /* Зоны */
        #game-table {
            position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; max-width: 700px; height: 220px;
            display: flex; justify-content: center; align-items: center; pointer-events: none;
        }
        .table-slot { width: 80px; height: 120px; margin: 0 6px; position: relative; pointer-events: none; }

        /* Руки */
        #player-hand {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            height: 140px; width: 100%; display: flex; justify-content: center; align-items: flex-end;
        }
        .hand-card-wrapper { margin-left: -35px; position: relative; width: 70px; height: 105px; transition: margin 0.2s; }
        .hand-card-wrapper:first-child { margin-left: 0; }
        .hand-card-wrapper:hover { margin-right: 20px; }

        #opponent-hand {
            position: absolute; top: -10px; left: 50%; transform: translateX(-50%);
            display: flex; justify-content: center;
        }
        .opponent-card-back {
            width: 50px; height: 80px; margin-left: -30px;
            background: repeating-linear-gradient(45deg, #1e3a8a, #1e3a8a 5px, #2563eb 5px, #2563eb 10px);
            border: 2px solid white; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* UI */
        .btn-primary {
            background: #2563eb; color: white; padding: 0.75rem 1.5rem; border-radius: 9999px; font-weight: bold;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); transition: all 0.2s; cursor: pointer;
        }
        .btn-primary:active { transform: scale(0.95); }
        .btn-secondary {
            background: #dc2626; color: white; padding: 0.75rem 1.5rem; border-radius: 9999px; font-weight: bold;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); transition: all 0.2s; cursor: pointer;
        }

        #lobby-screen { z-index: 1000; background: rgba(0,0,0,0.85); backdrop-filter: blur(5px); }
    </style>
</head>
<body class="h-screen w-screen text-gray-800">

    <!-- ЛОББИ -->
    <div id="lobby-screen" class="fixed inset-0 flex items-center justify-center text-white">
        <div class="bg-white text-gray-800 p-8 rounded-xl shadow-2xl max-w-md w-full mx-4 relative overflow-hidden">
            <h1 class="text-3xl font-bold mb-2 text-center text-blue-800">Дурак</h1>
            <p class="text-center text-gray-500 mb-6 text-sm">Карточная игра</p>
            
            <div id="lobby-main" class="space-y-4">
                <!-- ОФЛАЙН -->
                <button onclick="startOfflineGame()" class="w-full bg-gradient-to-r from-green-500 to-green-700 text-white font-bold py-4 rounded-lg shadow-lg hover:from-green-600 hover:to-green-800 transition transform hover:scale-105 flex items-center justify-center gap-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Играть с Ботом (Офлайн)
                </button>

                <div class="relative flex py-2 items-center">
                    <div class="flex-grow border-t border-gray-300"></div>
                    <span class="flex-shrink-0 mx-4 text-gray-400 text-xs uppercase">Или Онлайн</span>
                    <div class="flex-grow border-t border-gray-300"></div>
                </div>

                <!-- ОНЛАЙН -->
                <div id="online-controls" class="space-y-3 opacity-50 pointer-events-none transition-opacity">
                    <div class="text-xs text-center text-blue-600 mb-2" id="auth-status">Подключение к серверу...</div>
                    <button onclick="createOnlineGame()" class="w-full btn-primary bg-blue-600 hover:bg-blue-700 text-sm py-3">
                        Создать Онлайн Игру
                    </button>
                    <div class="flex gap-2">
                        <input id="join-game-id" type="text" placeholder="ID (6 цифр)" 
                               class="flex-1 border-2 border-gray-300 p-2 rounded-lg text-center font-mono uppercase text-sm">
                        <button onclick="joinOnlineGame()" class="btn-primary py-2 text-sm">Войти</button>
                    </div>
                </div>
            </div>

            <!-- Экран ожидания (онлайн) -->
            <div id="waiting-room" class="hidden text-center">
                <h2 class="text-xl font-bold mb-2">Ожидание игрока</h2>
                <div class="bg-yellow-100 p-4 rounded-lg mb-4 border-2 border-yellow-300">
                    <div class="text-sm text-gray-600">Код комнаты:</div>
                    <div id="display-game-id" class="text-4xl font-mono font-bold tracking-widest text-blue-700 select-all cursor-pointer" onclick="copyId()">------</div>
                </div>
                <button onclick="leaveGame()" class="text-red-500 hover:underline text-sm">Отмена</button>
            </div>
        </div>
    </div>

    <!-- ИГРОВОЙ ИНТЕРФЕЙС -->
    <div id="game-ui" class="hidden h-full w-full relative">
        <!-- Верхняя панель -->
        <div class="absolute top-0 left-0 w-full p-2 flex justify-between items-start z-10 pointer-events-none">
            <div id="status-badge" class="bg-gray-700 text-white px-4 py-2 rounded-full text-sm font-bold shadow-lg backdrop-blur-md pointer-events-auto transition-colors">
                Ожидание...
            </div>
            <div class="text-right pointer-events-auto flex flex-col items-end gap-2">
                <div class="bg-white/90 text-gray-900 px-3 py-1 rounded shadow text-sm font-bold flex items-center gap-2">
                    Козырь: <span id="trump-suit-display" class="text-xl leading-none"></span>
                </div>
                <button onclick="leaveGame()" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-xs shadow">Меню</button>
            </div>
        </div>

        <!-- Стол -->
        <div id="opponent-hand"></div>
        <div id="opponent-name" class="absolute top-16 left-1/2 transform -translate-x-1/2 text-white/70 text-sm font-bold bg-black/20 px-2 rounded">Соперник</div>

        <div id="deck-area" class="absolute left-4 top-1/2 transform -translate-y-1/2">
            <div class="relative w-[70px] h-[105px]">
                <div id="trump-card-el" class="absolute top-0 left-0 transition-all"></div>
                <div id="deck-stack" class="absolute top-0 left-0 w-full h-full bg-blue-900 border-2 border-white rounded-lg shadow-lg flex items-center justify-center">
                    <span id="deck-count" class="text-white font-bold text-xl">36</span>
                </div>
            </div>
        </div>

        <div id="game-table"></div>

        <div id="action-area" class="absolute bottom-44 left-1/2 transform -translate-x-1/2 z-50 transition-opacity opacity-0 pointer-events-none">
            <button id="main-action-btn" class="btn-primary pointer-events-auto shadow-2xl ring-4 ring-white/30 text-lg px-8 py-3">Действие</button>
        </div>

        <div id="player-hand"></div>

        <!-- Тосты -->
        <div id="toast" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black/80 text-white px-6 py-3 rounded-xl pointer-events-none transition-all opacity-0 scale-90 z-[200]">
            Сообщение
        </div>
    </div>

    <!-- ЛОГИКА -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, updateDoc, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL STATE ---
        let GAME_MODE = 'OFFLINE'; // 'ONLINE' or 'OFFLINE'
        let currentUser = { uid: 'player-offline' };
        let currentGameId = null;
        let unsubscribeGame = null;
        
        let localState = null; // Текущее состояние игры
        let botTimer = null;

        // --- FIREBASE INIT (Try-Catch for Safety) ---
        let db, auth, gamesRef;
        let isFirebaseReady = false;

        try {
            // Пытаемся взять конфиг среды
            const fbConfig = (typeof __firebase_config !== 'undefined') 
                ? JSON.parse(__firebase_config) 
                : { apiKey: "AIzaSyBlfCYqHw_uHxP6pyKOkW0QFsuHFw9_XyY" }; // Fallback (не сработает для Firestore без projectId)

            if (fbConfig.projectId) {
                const app = initializeApp(fbConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default';
                gamesRef = collection(db, 'artifacts', appId, 'public', 'data', 'games');
                
                // Auth
                const initAuth = async () => {
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                };
                initAuth();

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        currentUser = user;
                        isFirebaseReady = true;
                        document.getElementById('online-controls').classList.remove('opacity-50', 'pointer-events-none');
                        document.getElementById('auth-status').innerText = "Сервер подключен";
                        document.getElementById('auth-status').className = "text-xs text-center text-green-600 mb-2";
                    }
                });
            } else {
                document.getElementById('auth-status').innerText = "Онлайн недоступен (Нет конфига)";
                document.getElementById('auth-status').className = "text-xs text-center text-red-500 mb-2";
            }
        } catch (e) {
            console.log("Firebase init error (Offline mode only):", e);
        }

        // --- LOBBY FUNCTIONS ---

        window.startOfflineGame = () => {
            GAME_MODE = 'OFFLINE';
            currentUser = { uid: 'player' };
            
            // Инициализируем локальное состояние
            const deck = createDeck();
            const trump = deck[0];
            const pHand = [];
            const bHand = [];
            
            for(let i=0; i<6; i++) { pHand.push(deck.pop()); bHand.push(deck.pop()); }

            // Определяем первый ход
            let pMin = 100, bMin = 100;
            pHand.forEach(c => { if(c.suit === trump.suit && c.value < pMin) pMin = c.value; });
            bHand.forEach(c => { if(c.suit === trump.suit && c.value < bMin) bMin = c.value; });
            const playerFirst = pMin < bMin; // Если у бота нет козыря (100), а у игрока тоже (100) -> false (бот)

            localState = {
                status: 'playing',
                deck: deck,
                trumpCard: trump,
                trumpSuit: trump.suit,
                hands: { 'player': pHand, 'bot': bHand },
                table: [],
                turn: playerFirst ? 'player' : 'bot',
                attacker: playerFirst ? 'player' : 'bot',
                hostId: 'player',
                joinerId: 'bot'
            };

            showGameUI();
            renderGame(localState);
            
            if (localState.turn === 'bot') setTimeout(botTurn, 1000);
        };

        window.createOnlineGame = async () => {
            if (!isFirebaseReady) return showToast("Нет подключения к серверу");
            GAME_MODE = 'ONLINE';
            const gameId = Math.floor(100000 + Math.random() * 900000).toString();
            const deck = createDeck();
            
            const state = {
                hostId: currentUser.uid,
                joinerId: null,
                status: 'waiting',
                deck: deck,
                trumpCard: deck[0],
                trumpSuit: deck[0].suit,
                hands: { [currentUser.uid]: [] },
                table: [],
                turn: currentUser.uid,
                attacker: currentUser.uid,
                lastUpdate: serverTimestamp()
            };

            await setDoc(doc(gamesRef, gameId), state);
            currentGameId = gameId;
            document.getElementById('lobby-main').classList.add('hidden');
            document.getElementById('waiting-room').classList.remove('hidden');
            document.getElementById('display-game-id').innerText = gameId;
            subscribeToGame(gameId);
        };

        window.joinOnlineGame = async () => {
            if (!isFirebaseReady) return showToast("Нет подключения");
            const inputId = document.getElementById('join-game-id').value.trim();
            if (inputId.length !== 6) return showToast("Нужен ID из 6 цифр");
            GAME_MODE = 'ONLINE';

            const gameRef = doc(gamesRef, inputId);
            const snap = await getDoc(gameRef);
            if (!snap.exists()) return showToast("Игра не найдена");
            const data = snap.data();
            if (data.status !== 'waiting') return showToast("Игра занята");

            // Deal logic
            const deck = [...data.deck];
            const h1 = [], h2 = [];
            for(let i=0; i<6; i++) { if(deck.length) h1.push(deck.pop()); if(deck.length) h2.push(deck.pop()); }

            await updateDoc(gameRef, {
                joinerId: currentUser.uid,
                status: 'playing',
                deck: deck,
                [`hands.${data.hostId}`]: h1,
                [`hands.${currentUser.uid}`]: h2,
                attacker: data.hostId, // Хост ходит первым упрощенно
                turn: data.hostId
            });

            currentGameId = inputId;
            subscribeToGame(inputId);
        };

        function subscribeToGame(id) {
            unsubscribeGame = onSnapshot(doc(gamesRef, id), (snap) => {
                if(!snap.exists()) return leaveGame();
                const d = snap.data();
                localState = d;
                if (d.status === 'playing') {
                    showGameUI();
                    renderGame(d);
                }
            });
        }

        // --- CORE GAME RENDER & LOGIC ---

        function renderGame(state) {
            const myUid = GAME_MODE === 'OFFLINE' ? 'player' : currentUser.uid;
            const oppUid = GAME_MODE === 'OFFLINE' ? 'bot' : (state.hostId === myUid ? state.joinerId : state.hostId);

            // 1. Status Bar
            const isMyTurn = state.turn === myUid;
            const amIAttacker = state.attacker === myUid;
            const badge = document.getElementById('status-badge');
            
            if (isMyTurn) {
                badge.innerText = amIAttacker ? "Ваш ход: Атакуйте" : "Ваш ход: Отбивайтесь";
                badge.className = "px-4 py-2 rounded-full text-sm font-bold shadow-lg transition-colors bg-green-600 text-white animate-pulse";
            } else {
                badge.innerText = "Ход противника...";
                badge.className = "px-4 py-2 rounded-full text-sm font-bold shadow-lg transition-colors bg-gray-700 text-white";
            }

            // 2. Info
            const trump = state.trumpCard;
            const suitHtml = `<span class="${(trump.suit === 'hearts' || trump.suit === 'diamonds') ? 'text-red-500' : 'text-gray-900'}">${getSuitChar(trump.suit)}</span>`;
            document.getElementById('trump-suit-display').innerHTML = suitHtml;
            document.getElementById('deck-count').innerText = state.deck.length;

            const trumpEl = document.getElementById('trump-card-el');
            trumpEl.innerHTML = renderCardHTML(trump);
            trumpEl.style.transform = 'rotate(90deg) translateX(30px)';
            if (state.deck.length === 0) {
                document.getElementById('deck-stack').classList.add('hidden');
                trumpEl.style.opacity = '0.5';
            } else {
                document.getElementById('deck-stack').classList.remove('hidden');
                trumpEl.style.opacity = '1';
            }

            // 3. Table
            const tableEl = document.getElementById('game-table');
            tableEl.innerHTML = '';
            state.table.forEach(pair => {
                const slot = document.createElement('div');
                slot.className = 'table-slot';
                
                const att = document.createElement('div');
                att.className = 'card';
                att.innerHTML = renderCardHTML(pair.attack);
                slot.appendChild(att);

                if(pair.defend) {
                    const def = document.createElement('div');
                    def.className = 'card';
                    def.style.top = '20px'; def.style.left = '20px'; def.style.zIndex = 10;
                    def.innerHTML = renderCardHTML(pair.defend);
                    slot.appendChild(def);
                }
                tableEl.appendChild(slot);
            });

            // 4. My Hand
            const handEl = document.getElementById('player-hand');
            handEl.innerHTML = '';
            const myHand = state.hands[myUid] || [];
            
            // Sort
            myHand.sort((a,b) => {
                const trA = a.suit === state.trumpSuit;
                const trB = b.suit === state.trumpSuit;
                if(trA && !trB) return 1;
                if(!trA && trB) return -1;
                if(a.suit === b.suit) return a.value - b.value;
                return a.suit.localeCompare(b.suit);
            });

            myHand.forEach(card => {
                const wrap = document.createElement('div');
                wrap.className = 'hand-card-wrapper';
                const cDiv = document.createElement('div');
                cDiv.className = 'card hover:ring-2 ring-blue-400';
                cDiv.innerHTML = renderCardHTML(card);
                cDiv.onclick = () => playerCardClick(card);
                wrap.appendChild(cDiv);
                handEl.appendChild(wrap);
            });

            // 5. Opponent Hand
            const oppHandEl = document.getElementById('opponent-hand');
            oppHandEl.innerHTML = '';
            const oppCount = (state.hands[oppUid] || []).length;
            for(let i=0; i<oppCount; i++) {
                const back = document.createElement('div');
                back.className = 'opponent-card-back';
                oppHandEl.appendChild(back);
            }

            // 6. Buttons
            const btnArea = document.getElementById('action-area');
            const btn = document.getElementById('main-action-btn');
            
            if (state.table.length === 0) {
                btnArea.classList.add('opacity-0', 'pointer-events-none');
            } else if (isMyTurn) {
                btnArea.classList.remove('opacity-0', 'pointer-events-none');
                if (amIAttacker) {
                    // Attack phase
                    const allDefended = state.table.every(p => p.defend);
                    if (allDefended) {
                        btn.innerText = "Бито";
                        btn.className = "btn-primary bg-green-600 hover:bg-green-700 text-lg px-8 py-3 shadow-green-500/50";
                        btn.onclick = () => performAction('bito');
                    } else {
                        btnArea.classList.add('opacity-0', 'pointer-events-none'); // Wait for defender
                    }
                } else {
                    // Defend phase
                    btn.innerText = "Взять";
                    btn.className = "btn-secondary bg-red-600 hover:bg-red-700 text-lg px-8 py-3 shadow-red-500/50";
                    btn.onclick = () => performAction('take');
                }
            } else {
                btnArea.classList.add('opacity-0', 'pointer-events-none');
            }
        }

        // --- ACTIONS ---

        window.playerCardClick = (card) => {
            const state = localState;
            const myUid = GAME_MODE === 'OFFLINE' ? 'player' : currentUser.uid;
            
            if (state.turn !== myUid) return showToast("Не ваш ход!");

            const amIAttacker = state.attacker === myUid;
            
            if (amIAttacker) {
                // Check if valid attack (match existing ranks)
                if (state.table.length > 0) {
                    const validRanks = new Set();
                    state.table.forEach(p => { validRanks.add(p.attack.rank); if(p.defend) validRanks.add(p.defend.rank); });
                    if (!validRanks.has(card.rank)) return showToast("Карта не подходит (ранг)");
                }
                if (state.table.length >= 6) return showToast("Стол полон");
                
                applyMove(card, 'attack');
            } else {
                // Defend
                const pairIdx = state.table.findIndex(p => !p.defend);
                if (pairIdx === -1) return; // All defended
                
                const att = state.table[pairIdx].attack;
                let beats = false;
                if (card.suit === att.suit && card.value > att.value) beats = true;
                else if (card.suit === state.trumpSuit && att.suit !== state.trumpSuit) beats = true;
                
                if (!beats) return showToast("Этой картой нельзя побить");
                
                applyMove(card, 'defend', pairIdx);
            }
        };

        window.performAction = (type) => {
            if (GAME_MODE === 'OFFLINE') {
                processOfflineAction(type);
            } else {
                processOnlineAction(type);
            }
        };

        async function applyMove(card, type, idx = -1) {
            const myUid = GAME_MODE === 'OFFLINE' ? 'player' : currentUser.uid;
            
            // Оптимистичное удаление из руки
            localState.hands[myUid] = localState.hands[myUid].filter(c => !(c.rank===card.rank && c.suit===card.suit));
            
            if (type === 'attack') {
                localState.table.push({ attack: card, defend: null });
                // Смена хода: если атаковал, ход переходит защитнику
                const oppId = GAME_MODE==='OFFLINE' ? 'bot' : (localState.hostId===myUid ? localState.joinerId : localState.hostId);
                localState.turn = oppId;
            } else {
                localState.table[idx].defend = card;
                // Смена хода: если отбился, ход возвращается атакующему (может подкинуть)
                localState.turn = localState.attacker;
            }

            renderGame(localState);

            if (GAME_MODE === 'ONLINE') {
                await updateDoc(doc(gamesRef, currentGameId), {
                    [`hands.${myUid}`]: localState.hands[myUid],
                    table: localState.table,
                    turn: localState.turn
                });
            } else {
                if (localState.turn === 'bot') setTimeout(botTurn, 1000);
            }
        }

        // --- OFFLINE / BOT LOGIC ---

        function processOfflineAction(action) {
            const state = localState;
            const oppId = 'bot';
            const myId = 'player';
            
            if (action === 'bito') {
                drawCards(myId, oppId);
                state.table = [];
                state.attacker = oppId; 
                state.turn = oppId;
                renderGame(state);
                setTimeout(botTurn, 1000);
            } else if (action === 'take') {
                takeCards(myId); // Игрок берет
                drawCards(oppId); // Бот добирает
                state.table = [];
                state.attacker = oppId; // Бот снова атакует
                state.turn = oppId;
                renderGame(state);
                setTimeout(botTurn, 1000);
            }
        }

        function botTurn() {
            if (!localState || GAME_MODE !== 'OFFLINE') return;
            const state = localState;
            const botHand = state.hands['bot'];
            const amIAttacker = state.attacker === 'bot';

            if (amIAttacker) {
                // АТАКА БОТА
                if (state.table.length === 0) {
                    // Кидаем самую мелкую
                    const c = getLowestCard(botHand, state.trumpSuit);
                    botApplyMove(c, 'attack');
                } else {
                    // Подкидываем
                    const ranks = new Set();
                    state.table.forEach(p => { ranks.add(p.attack.rank); if(p.defend) ranks.add(p.defend.rank); });
                    const options = botHand.filter(c => ranks.has(c.rank));
                    
                    if (options.length > 0) {
                        options.sort((a,b) => a.value - b.value);
                        botApplyMove(options[0], 'attack');
                    } else {
                        // Бито
                        botDoAction('bito');
                    }
                }
            } else {
                // ЗАЩИТА БОТА
                const pairIdx = state.table.findIndex(p => !p.defend);
                if (pairIdx === -1) return; // Ждем атакующего
                
                const att = state.table[pairIdx].attack;
                // Ищем чем побить
                let beaters = botHand.filter(c => {
                    if (c.suit === att.suit) return c.value > att.value;
                    if (c.suit === state.trumpSuit && att.suit !== state.trumpSuit) return true;
                    return false;
                });

                if (beaters.length > 0) {
                    // Бьем самой дешевой
                    beaters.sort((a,b) => {
                        const trA = a.suit === state.trumpSuit ? 1 : 0;
                        const trB = b.suit === state.trumpSuit ? 1 : 0;
                        if (trA !== trB) return trA - trB;
                        return a.value - b.value;
                    });
                    botApplyMove(beaters[0], 'defend', pairIdx);
                } else {
                    botDoAction('take');
                }
            }
        }

        function botApplyMove(card, type, idx) {
            const state = localState;
            state.hands['bot'] = state.hands['bot'].filter(c => c !== card);
            
            if (type === 'attack') {
                state.table.push({ attack: card, defend: null });
                state.turn = 'player';
            } else {
                state.table[idx].defend = card;
                state.turn = 'bot'; // Вернули ход атакующему боту
            }
            renderGame(state);
            // Если бот отбился, он тут же проверяет может ли подкинуть (через задержку)
            if (type === 'defend') setTimeout(botTurn, 1000);
        }

        function botDoAction(action) {
            const state = localState;
            if (action === 'bito') {
                showToast("Бот: Бито!");
                drawCards('bot', 'player');
                state.table = [];
                state.attacker = 'player';
                state.turn = 'player';
                renderGame(state);
            } else if (action === 'take') {
                showToast("Бот берет карты");
                takeCards('bot');
                drawCards('player');
                state.table = [];
                state.attacker = 'player';
                state.turn = 'player';
                renderGame(state);
            }
        }

        // --- ONLINE ACTIONS ---
        async function processOnlineAction(action) {
            const myUid = currentUser.uid;
            const oppUid = localState.hostId === myUid ? localState.joinerId : localState.hostId;
            const ref = doc(gamesRef, currentGameId);
            
            if (action === 'bito') {
                // Локально считаем логику добора
                let d = [...localState.deck];
                let h = { ...localState.hands };
                const uids = [localState.attacker, (localState.attacker===myUid?oppUid:myUid)]; // Сначала атакующий
                
                uids.forEach(uid => {
                    while(h[uid].length < 6 && d.length > 0) h[uid].push(d.pop());
                });

                await updateDoc(ref, {
                    table: [], deck: d, hands: h,
                    attacker: oppUid, turn: oppUid
                });

            } else if (action === 'take') {
                let d = [...localState.deck];
                let h = { ...localState.hands };
                let cards = [];
                localState.table.forEach(p => { cards.push(p.attack); if(p.defend) cards.push(p.defend); });
                
                h[myUid] = [...h[myUid], ...cards]; // Тот кто нажал взять
                while(h[oppUid].length < 6 && d.length > 0) h[oppUid].push(d.pop()); // Атакующий добирает

                await updateDoc(ref, {
                    table: [], deck: d, hands: h,
                    attacker: oppUid, turn: oppUid
                });
            }
        }

        // --- UTILS ---
        
        function drawCards(attId, defId) { // для офлайна
            const state = localState;
            // Порядок: Сначала атакующий, потом защитник (упрощенно)
            [attId, defId].forEach(id => {
                if (!id) return;
                while(state.hands[id].length < 6 && state.deck.length > 0) state.hands[id].push(state.deck.pop());
            });
        }

        function takeCards(takerId) {
            const state = localState;
            state.table.forEach(p => {
                state.hands[takerId].push(p.attack);
                if(p.defend) state.hands[takerId].push(p.defend);
            });
        }

        function getLowestCard(hand, trumpSuit) {
            return hand.reduce((p, c) => {
                const trP = p.suit===trumpSuit?1:0;
                const trC = c.suit===trumpSuit?1:0;
                if(trP !== trC) return trP < trC ? p : c;
                return p.value < c.value ? p : c;
            });
        }

        function createDeck() {
            const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
            const ranks = ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
            const values = { '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
            let d = [];
            for (let s of suits) for (let r of ranks) d.push({ suit: s, rank: r, value: values[r] });
            for (let i = d.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [d[i], d[j]] = [d[j], d[i]]; }
            return d;
        }

        function renderCardHTML(card) {
            const color = (card.suit === 'hearts' || card.suit === 'diamonds') ? 'suit-red' : 'suit-black';
            return `<div class="text-left font-bold text-sm leading-none ${color}">${card.rank}</div>
                    <div class="flex-grow flex items-center justify-center text-3xl ${color}">${getSuitChar(card.suit)}</div>
                    <div class="text-right font-bold text-sm leading-none transform rotate-180 ${color}">${card.rank}</div>`;
        }
        function getSuitChar(s) { return { 'hearts': '♥', 'diamonds': '♦', 'clubs': '♣', 'spades': '♠' }[s]; }

        window.showGameUI = () => {
            document.getElementById('lobby-screen').classList.add('hidden');
            document.getElementById('game-ui').classList.remove('hidden');
        };
        window.leaveGame = () => {
            if (unsubscribeGame) unsubscribeGame();
            document.getElementById('game-ui').classList.add('hidden');
            document.getElementById('lobby-screen').classList.remove('hidden');
            document.getElementById('lobby-main').classList.remove('hidden');
            document.getElementById('waiting-room').classList.add('hidden');
            localState = null;
        };
        window.copyId = () => { navigator.clipboard.writeText(currentGameId); showToast("ID Скопирован"); }
        window.showToast = (m) => {
            const t = document.getElementById('toast');
            t.innerText = m; t.classList.remove('opacity-0', 'scale-90');
            setTimeout(() => t.classList.add('opacity-0', 'scale-90'), 2000);
        };
    </script>
</body>
</html>
