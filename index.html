<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Дурак Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@500&display=swap');
        
        body {
            background-color: #2e7d32;
            background-image: radial-gradient(#358e39 15%, transparent 16%), radial-gradient(#358e39 15%, transparent 16%);
            background-size: 60px 60px;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            user-select: none;
            touch-action: manipulation;
        }

        /* Анимации и стили карт */
        .card {
            width: 70px;
            height: 105px;
            background-color: white;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 4px;
            position: absolute;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            border: 1px solid #ccc;
        }
        .card:hover { transform: translateY(-10px); z-index: 50 !important; }
        .card.selected { border: 2px solid #3b82f6; transform: translateY(-15px); }
        .suit-red { color: #e53e3e; }
        .suit-black { color: #1a202c; }
        
        @media (min-width: 640px) {
            .card { width: 90px; height: 135px; padding: 6px; }
        }

        /* Зоны */
        #game-table {
            position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; max-width: 700px; height: 220px;
            display: flex; justify-content: center; align-items: center;
        }
        .table-slot { width: 80px; height: 120px; margin: 0 6px; position: relative; }

        /* Руки */
        #player-hand {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            height: 140px; width: 100%; display: flex; justify-content: center; align-items: flex-end;
        }
        .hand-card-wrapper { margin-left: -35px; position: relative; width: 70px; height: 105px; transition: margin 0.2s; }
        .hand-card-wrapper:first-child { margin-left: 0; }
        .hand-card-wrapper:hover { margin-right: 20px; }

        #opponent-hand {
            position: absolute; top: -10px; left: 50%; transform: translateX(-50%);
            display: flex; justify-content: center;
        }
        .opponent-card-back {
            width: 50px; height: 80px; margin-left: -30px;
            background: repeating-linear-gradient(45deg, #1e3a8a, #1e3a8a 5px, #2563eb 5px, #2563eb 10px);
            border: 2px solid white; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* UI Элементы */
        .btn-primary {
            background: #2563eb; color: white; padding: 0.75rem 1.5rem; border-radius: 9999px; font-weight: bold;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); transition: all 0.2s;
        }
        .btn-primary:active { transform: scale(0.95); }
        .btn-secondary {
            background: #dc2626; color: white; padding: 0.75rem 1.5rem; border-radius: 9999px; font-weight: bold;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); transition: all 0.2s;
        }

        /* Лобби */
        #lobby-screen { z-index: 1000; background: rgba(0,0,0,0.85); backdrop-filter: blur(5px); }
    </style>
</head>
<body class="h-screen w-screen text-gray-800">

    <!-- ЭКРАН ЛОББИ -->
    <div id="lobby-screen" class="fixed inset-0 flex items-center justify-center text-white">
        <div class="bg-white text-gray-800 p-8 rounded-xl shadow-2xl max-w-md w-full mx-4">
            <h1 class="text-3xl font-bold mb-6 text-center text-blue-800">Дурак Online</h1>
            
            <div id="auth-loading" class="text-center py-4">Подключение к серверу...</div>
            
            <div id="lobby-menu" class="hidden space-y-4">
                <div class="p-3 bg-blue-50 rounded text-sm text-blue-800 mb-4">
                    Ваш ID: <span id="my-user-id" class="font-mono font-bold">...</span>
                </div>
                
                <button onclick="createGame()" class="w-full btn-primary bg-green-600 hover:bg-green-700">
                    Создать новую игру
                </button>
                
                <div class="relative flex py-2 items-center">
                    <div class="flex-grow border-t border-gray-300"></div>
                    <span class="flex-shrink-0 mx-4 text-gray-400">ИЛИ</span>
                    <div class="flex-grow border-t border-gray-300"></div>
                </div>

                <div class="flex gap-2">
                    <input id="join-game-id" type="text" placeholder="ID Комнаты (6 цифр)" 
                           class="flex-1 border-2 border-gray-300 p-3 rounded-lg focus:outline-none focus:border-blue-500 font-mono text-center uppercase" maxlength="6">
                    <button onclick="joinGame()" class="btn-primary">Войти</button>
                </div>
            </div>

            <div id="waiting-room" class="hidden text-center">
                <h2 class="text-xl font-bold mb-2">Ожидание соперника</h2>
                <div class="bg-yellow-100 p-4 rounded-lg mb-4 border-2 border-yellow-300">
                    <div class="text-sm text-gray-600">Код комнаты:</div>
                    <div id="display-game-id" class="text-4xl font-mono font-bold tracking-widest text-blue-700 select-all">------</div>
                </div>
                <p class="text-sm text-gray-500 mb-6">Сообщите этот код другу</p>
                <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
            </div>
        </div>
    </div>

    <!-- ИГРОВОЙ ИНТЕРФЕЙС -->
    <div id="game-ui" class="hidden h-full w-full relative">
        
        <!-- Инфо панель -->
        <div class="absolute top-0 left-0 w-full p-2 flex justify-between items-start z-10 pointer-events-none">
            <div class="bg-black/40 text-white px-3 py-1 rounded text-sm backdrop-blur-sm pointer-events-auto">
                <span id="game-status-text">Ожидание...</span>
            </div>
            <div class="text-right pointer-events-auto">
                <div class="bg-white text-gray-900 px-3 py-1 rounded shadow text-sm font-bold mb-1">
                    Козырь: <span id="trump-suit-display" class="text-lg"></span>
                </div>
                <button onclick="leaveGame()" class="bg-red-500/80 hover:bg-red-600 text-white px-2 py-1 rounded text-xs">Выход</button>
            </div>
        </div>

        <!-- Рука противника -->
        <div id="opponent-hand">
            <!-- Карты генерируются JS -->
        </div>
        <div id="opponent-name" class="absolute top-16 left-1/2 transform -translate-x-1/2 text-white/70 text-sm font-bold bg-black/20 px-2 rounded">
            Соперник
        </div>

        <!-- Колода -->
        <div id="deck-area" class="absolute left-4 top-1/2 transform -translate-y-1/2">
            <div id="trump-card-container" class="relative" style="width: 70px; height: 105px;">
                <!-- Козырь (повернут) -->
                <div id="trump-card-el" class="absolute top-0 left-0 transition-all"></div>
                <!-- Колода (сверху) -->
                <div id="deck-stack" class="absolute top-0 left-0 w-full h-full bg-blue-900 border-2 border-white rounded-lg shadow-lg flex items-center justify-center">
                    <span id="deck-count" class="text-white font-bold text-xl">36</span>
                </div>
            </div>
        </div>

        <!-- Стол -->
        <div id="game-table"></div>

        <!-- Кнопки действий -->
        <div id="action-area" class="absolute bottom-40 left-1/2 transform -translate-x-1/2 z-50 transition-opacity opacity-0 pointer-events-none">
            <button id="main-action-btn" class="btn-primary pointer-events-auto shadow-xl ring-2 ring-white/50 text-lg px-8">
                Действие
            </button>
        </div>

        <!-- Рука игрока -->
        <div id="player-hand"></div>

        <!-- Уведомления -->
        <div id="toast" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black/80 text-white px-6 py-3 rounded-xl pointer-events-none transition-opacity opacity-0 z-[200]">
            Сообщение
        </div>
    </div>

    <!-- Логика Firebase и Игры -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, collection, doc, setDoc, getDoc, updateDoc, onSnapshot, 
            arrayUnion, serverTimestamp, increment 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- КОНФИГУРАЦИЯ ---
        // Пытаемся взять конфиг из среды (для предпросмотра), иначе используем заглушку с твоим ключом.
        // В реальном проекте здесь должен быть полный объект конфигурации.
        let firebaseConfig;
        const userProvidedKey = "AIzaSyBlfCYqHw_uHxP6pyKOkW0QFsuHFw9_XyY";
        
        try {
            if (typeof __firebase_config !== 'undefined') {
                firebaseConfig = JSON.parse(__firebase_config);
                console.log("Using environment config");
            } else {
                throw new Error("No env config");
            }
        } catch (e) {
            console.log("Using fallback config with provided key");
            // Внимание: Без projectId и authDomain этот конфиг может не сработать для Firestore
            // Но мы используем его как placeholder, надеясь, что среда подставит нужное.
            firebaseConfig = {
                apiKey: userProvidedKey,
                authDomain: "durak-game-demo.firebaseapp.com", // Пример
                projectId: "durak-game-demo", // Пример
                storageBucket: "durak-game-demo.appspot.com",
            };
        }

        // --- ИНИЦИАЛИЗАЦИЯ ---
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // Используем __app_id из среды для путей Firestore, или дефолтный
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        
        // Ссылка на коллекцию игр
        // Правило 1: /artifacts/{appId}/public/data/games
        const gamesRef = collection(db, 'artifacts', appId, 'public', 'data', 'games');

        let currentUser = null;
        let currentGameId = null;
        let unsubscribeGame = null;
        let localState = null; // Локальная копия состояния игры
        
        // --- AUTH ---
        // Правило 3: Сначала авторизация
        async function initAuth() {
            try {
                // Сначала пробуем токен из среды, если есть (для предпросмотра)
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js")
                        .then(m => m.signInWithCustomToken(auth, __initial_auth_token));
                } else {
                    await signInAnonymously(auth);
                }
            } catch (err) {
                console.error("Auth failed:", err);
                showToast("Ошибка подключения к серверу");
            }
        }

        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                document.getElementById('auth-loading').classList.add('hidden');
                document.getElementById('lobby-menu').classList.remove('hidden');
                document.getElementById('my-user-id').innerText = user.uid.substring(0, 5);
            }
        });

        initAuth();

        // --- LOBBY LOGIC ---

        window.createGame = async () => {
            if (!currentUser) return;
            
            const gameId = Math.floor(100000 + Math.random() * 900000).toString();
            const initialDeck = createDeck();
            const trump = initialDeck[0]; // Первая карта - козырь (будет внизу)
            
            // Состояние новой игры
            const gameState = {
                hostId: currentUser.uid,
                joinerId: null,
                status: 'waiting',
                deck: initialDeck,
                trumpCard: trump,
                trumpSuit: trump.suit,
                hands: { [currentUser.uid]: [] }, // Карты раздадутся, когда второй войдет
                table: [], // { attack: card, defend: card, attackerId: uid }
                turn: currentUser.uid, // Ход (кто атакует)
                attacker: currentUser.uid,
                lastUpdate: serverTimestamp()
            };

            try {
                await setDoc(doc(gamesRef, gameId), gameState);
                currentGameId = gameId;
                showWaitingScreen(gameId);
                subscribeToGame(gameId);
            } catch (e) {
                console.error(e);
                showToast("Ошибка создания игры: " + e.message);
            }
        };

        window.joinGame = async () => {
            if (!currentUser) return;
            const inputId = document.getElementById('join-game-id').value.trim();
            if (inputId.length !== 6) return showToast("Введите 6 цифр ID");

            try {
                const gameDocRef = doc(gamesRef, inputId);
                const snapshot = await getDoc(gameDocRef);
                
                if (!snapshot.exists()) return showToast("Игра не найдена");
                const data = snapshot.data();
                
                if (data.status !== 'waiting') return showToast("Игра уже идет или завершена");
                if (data.hostId === currentUser.uid) return showToast("Вы не можете играть сами с собой");

                // Раздача карт для начала
                const deck = [...data.deck];
                const hostHand = [];
                const joinerHand = [];
                
                // Раздаем по 6
                for(let i=0; i<6; i++) {
                    if(deck.length) hostHand.push(deck.pop());
                    if(deck.length) joinerHand.push(deck.pop());
                }

                // Определяем кто первый (у кого меньший козырь)
                // Для простоты оставим хоста, или можно реализовать логику.
                // Оставим хоста атакующим по умолчанию для скорости.

                await updateDoc(gameDocRef, {
                    joinerId: currentUser.uid,
                    status: 'playing',
                    deck: deck,
                    [`hands.${data.hostId}`]: hostHand,
                    [`hands.${currentUser.uid}`]: joinerHand,
                    turn: data.hostId, // Хост ходит первым
                    attacker: data.hostId,
                    lastUpdate: serverTimestamp()
                });

                currentGameId = inputId;
                subscribeToGame(inputId);

            } catch (e) {
                console.error(e);
                showToast("Ошибка входа: " + e.message);
            }
        };

        function subscribeToGame(gameId) {
            if (unsubscribeGame) unsubscribeGame();

            const gameDocRef = doc(gamesRef, gameId);
            
            unsubscribeGame = onSnapshot(gameDocRef, (docSnap) => {
                if (!docSnap.exists()) {
                    showToast("Игра удалена");
                    leaveGame();
                    return;
                }

                const data = docSnap.data();
                localState = data;
                
                if (data.status === 'waiting') {
                    // Ждем...
                } else if (data.status === 'playing') {
                    showGameUI();
                    renderGame(data);
                } else if (data.status === 'finished') {
                    showToast("Игра окончена!");
                    setTimeout(leaveGame, 3000);
                }
            }, (error) => {
                console.error("Game sync error:", error);
                showToast("Ошибка синхронизации");
            });
        }

        window.leaveGame = () => {
            if (unsubscribeGame) unsubscribeGame();
            currentGameId = null;
            localState = null;
            document.getElementById('game-ui').classList.add('hidden');
            document.getElementById('lobby-screen').classList.remove('hidden');
            document.getElementById('lobby-menu').classList.remove('hidden');
            document.getElementById('waiting-room').classList.add('hidden');
        };

        function showWaitingScreen(id) {
            document.getElementById('lobby-menu').classList.add('hidden');
            document.getElementById('waiting-room').classList.remove('hidden');
            document.getElementById('display-game-id').innerText = id;
        }

        function showGameUI() {
            document.getElementById('lobby-screen').classList.add('hidden');
            document.getElementById('game-ui').classList.remove('hidden');
        }

        // --- GAME LOGIC (CLIENT SIDE) ---

        function renderGame(state) {
            const myUid = currentUser.uid;
            const oppUid = state.hostId === myUid ? state.joinerId : state.hostId;
            
            // 1. Статус
            const isMyTurn = state.turn === myUid;
            const amIAttacker = state.attacker === myUid;
            const statusText = isMyTurn 
                ? (amIAttacker ? "Ваш ход: Атакуйте" : "Ваш ход: Отбивайтесь") 
                : (amIAttacker ? "Ждем защиты соперника..." : "Соперник думает...");
            
            document.getElementById('game-status-text').innerText = statusText;
            document.getElementById('game-status-text').parentElement.className = isMyTurn 
                ? "bg-green-600 text-white px-3 py-1 rounded text-sm shadow animate-pulse" 
                : "bg-gray-700 text-white px-3 py-1 rounded text-sm shadow";

            // 2. Колода и козырь
            const trumpCard = state.trumpCard;
            const suitSymbol = getSuitSymbol(trumpCard.suit);
            const suitColor = (trumpCard.suit === 'hearts' || trumpCard.suit === 'diamonds') ? 'text-red-500' : 'text-gray-800';
            
            document.getElementById('trump-suit-display').innerHTML = `<span class="${suitColor}">${suitSymbol}</span>`;
            document.getElementById('deck-count').innerText = state.deck.length;
            
            // Отрисовка козыря под колодой
            const trumpEl = document.getElementById('trump-card-el');
            trumpEl.innerHTML = createCardHTML(trumpCard);
            trumpEl.style.transform = 'rotate(90deg) translateX(30px)';
            
            if (state.deck.length === 0) {
                document.getElementById('deck-stack').classList.add('hidden');
                // Если колода кончилась, козырь тоже исчезает (или остается, если это последняя карта, тут упростим)
                trumpEl.style.opacity = '0.5'; 
            } else {
                document.getElementById('deck-stack').classList.remove('hidden');
                trumpEl.style.opacity = '1';
            }

            // 3. Стол
            const tableEl = document.getElementById('game-table');
            tableEl.innerHTML = '';
            state.table.forEach(pair => {
                const slot = document.createElement('div');
                slot.className = 'table-slot';
                
                // Атака
                const attDiv = document.createElement('div');
                attDiv.className = 'card';
                attDiv.innerHTML = createCardHTML(pair.attack);
                slot.appendChild(attDiv);

                // Защита
                if (pair.defend) {
                    const defDiv = document.createElement('div');
                    defDiv.className = 'card';
                    defDiv.innerHTML = createCardHTML(pair.defend);
                    defDiv.style.top = '20px';
                    defDiv.style.left = '20px';
                    defDiv.style.zIndex = 10;
                    slot.appendChild(defDiv);
                }
                tableEl.appendChild(slot);
            });

            // 4. Моя рука
            const myHand = state.hands[myUid] || [];
            const handEl = document.getElementById('player-hand');
            handEl.innerHTML = '';
            
            // Сортировка руки
            myHand.sort((a,b) => {
                // Козыри в конец, потом по рангу
                const isTrumpA = a.suit === state.trumpSuit;
                const isTrumpB = b.suit === state.trumpSuit;
                if(isTrumpA && !isTrumpB) return 1;
                if(!isTrumpA && isTrumpB) return -1;
                if(a.suit === b.suit) return a.value - b.value;
                return a.suit.localeCompare(b.suit);
            });

            myHand.forEach(card => {
                const wrap = document.createElement('div');
                wrap.className = 'hand-card-wrapper';
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                cardDiv.innerHTML = createCardHTML(card);
                
                // Клик по карте
                cardDiv.onclick = () => handleCardClick(card, state);

                wrap.appendChild(cardDiv);
                handEl.appendChild(wrap);
            });

            // 5. Рука противника (рубашки)
            const oppHandSize = (state.hands[oppUid] || []).length;
            const oppHandEl = document.getElementById('opponent-hand');
            oppHandEl.innerHTML = '';
            for(let i=0; i<oppHandSize; i++) {
                const back = document.createElement('div');
                back.className = 'opponent-card-back';
                oppHandEl.appendChild(back);
            }

            // 6. Кнопки действий
            updateActionButtons(state, myUid);
        }

        function createCardHTML(card) {
            const suitSym = getSuitSymbol(card.suit);
            const colorClass = (card.suit === 'hearts' || card.suit === 'diamonds') ? 'suit-red' : 'suit-black';
            return `
                <div class="text-left font-bold text-sm leading-none ${colorClass}">${card.rank}</div>
                <div class="flex-grow flex items-center justify-center text-3xl ${colorClass}">${suitSym}</div>
                <div class="text-right font-bold text-sm leading-none transform rotate-180 ${colorClass}">${card.rank}</div>
            `;
        }

        function getSuitSymbol(suit) {
            const map = { 'hearts': '♥', 'diamonds': '♦', 'clubs': '♣', 'spades': '♠' };
            return map[suit] || suit;
        }

        function updateActionButtons(state, myUid) {
            const btnArea = document.getElementById('action-area');
            const btn = document.getElementById('main-action-btn');
            const amIAttacker = state.attacker === myUid;
            const isMyTurn = state.turn === myUid;

            // Если стол пустой, кнопок нет (надо кинуть карту)
            if (state.table.length === 0) {
                btnArea.classList.add('opacity-0');
                btnArea.classList.add('pointer-events-none');
                return;
            }

            if (isMyTurn) {
                btnArea.classList.remove('opacity-0');
                btnArea.classList.remove('pointer-events-none');
                
                if (amIAttacker) {
                    // Атакующий может нажать "Бито", если все отбито
                    const allDefended = state.table.every(p => p.defend);
                    if (allDefended) {
                        btn.innerText = "Бито";
                        btn.className = "btn-primary bg-green-600 hover:bg-green-700";
                        btn.onclick = () => doAction('bito');
                    } else {
                         // Ждет ответа соперника, кнопка скрыта или неактивна
                         btnArea.classList.add('opacity-0');
                         btnArea.classList.add('pointer-events-none');
                    }
                } else {
                    // Защищающийся может нажать "Взять"
                    btn.innerText = "Взять";
                    btn.className = "btn-secondary";
                    btn.onclick = () => doAction('take');
                }
            } else {
                btnArea.classList.add('opacity-0');
                btnArea.classList.add('pointer-events-none');
            }
        }

        // --- GAMEPLAY ACTIONS ---

        async function handleCardClick(card, state) {
            const myUid = currentUser.uid;
            if (state.turn !== myUid) return showToast("Не ваш ход");

            const amIAttacker = state.attacker === myUid;
            const table = state.table;

            // Логика АТАКИ
            if (amIAttacker) {
                // Если стол пуст - любую
                // Если не пуст - только совпадающую по рангу с теми что на столе
                const canAttack = table.length === 0 || table.some(p => p.attack.rank === card.rank || (p.defend && p.defend.rank === card.rank));
                
                if (!canAttack) return showToast("Карта не подходит (нет такого ранга на столе)");
                if (table.length >= 6) return showToast("Стол полон");

                // Ходим
                await submitMove(card, 'attack');
            } 
            // Логика ЗАЩИТЫ
            else {
                // Ищем первую неотбитую пару
                const pairIndex = table.findIndex(p => !p.defend);
                if (pairIndex === -1) return showToast("Все карты уже отбиты");

                const attackCard = table[pairIndex].attack;
                
                // Проверка бития
                let beats = false;
                if (card.suit === attackCard.suit) {
                    beats = card.value > attackCard.value;
                } else if (card.suit === state.trumpSuit) {
                    beats = true;
                }

                if (!beats) return showToast("Этой картой нельзя отбиться");

                await submitMove(card, 'defend', pairIndex);
            }
        }

        async function submitMove(card, type, pairIndex = -1) {
            if (!currentGameId) return;
            const gameRef = doc(gamesRef, currentGameId);
            const myUid = currentUser.uid;
            
            // Оптимистичное обновление или просто отправка
            // Копируем стейт
            let newHands = { ...localState.hands };
            newHands[myUid] = newHands[myUid].filter(c => !(c.rank === card.rank && c.suit === card.suit));
            
            let newTable = [...localState.table];
            if (type === 'attack') {
                newTable.push({ attack: card, defend: null, attackerId: myUid });
                // Если мы атаковали (подкинули), ход передается защитнику
                // НЕТ! В Дураке пока не отбито - ход все еще у атакующего (ждет ответа)
                // Но технически очередь действий переходит к защитнику
                await updateDoc(gameRef, {
                    [`hands.${myUid}`]: newHands[myUid],
                    table: newTable,
                    turn: localState.attacker === myUid ? (localState.hostId === myUid ? localState.joinerId : localState.hostId) : localState.attacker
                    // Логика сложнее: 
                    // 1. Атакующий кладет карту -> `turn` переходит к Defenser чтобы он побил.
                });
                
                // Исправляем логику смены хода:
                // Если я Attacker и я положил карту, теперь Turn у Defender
                const opponentId = localState.hostId === myUid ? localState.joinerId : localState.hostId;
                await updateDoc(gameRef, {
                    [`hands.${myUid}`]: newHands[myUid],
                    table: newTable,
                    turn: opponentId
                });

            } else {
                // Defend
                newTable[pairIndex].defend = card;
                
                // Если защитился, проверяем все ли отбито
                // Если все отбито, Turn переходит обратно к Attacker (он может подкинуть или нажать Бито)
                await updateDoc(gameRef, {
                    [`hands.${myUid}`]: newHands[myUid],
                    table: newTable,
                    turn: localState.attacker
                });
            }
        }

        async function doAction(action) {
            if (!currentGameId) return;
            const gameRef = doc(gamesRef, currentGameId);
            const data = localState;
            const myUid = currentUser.uid;
            const opponentId = data.hostId === myUid ? data.joinerId : data.hostId;

            if (action === 'bito') {
                // Карты уходят в отбой (просто стираем стол)
                // Добираем карты
                let deck = [...data.deck];
                let hands = { ...data.hands };
                
                // Сначала атакующий (myUid) добирает, потом защитник
                // Но "Бито" жмет атакующий
                [myUid, opponentId].forEach(uid => {
                    while(hands[uid].length < 6 && deck.length > 0) {
                        hands[uid].push(deck.pop()); // pop с конца массива (верх колоды)
                    }
                });

                // Смена ролей: бывший защитник становится атакующим
                await updateDoc(gameRef, {
                    table: [],
                    deck: deck,
                    hands: hands,
                    attacker: opponentId,
                    turn: opponentId
                });

            } else if (action === 'take') {
                // Забираем все карты со стола
                let cardsToTake = [];
                data.table.forEach(p => {
                    cardsToTake.push(p.attack);
                    if(p.defend) cardsToTake.push(p.defend);
                });

                let hands = { ...data.hands };
                hands[myUid] = [...hands[myUid], ...cardsToTake];

                // Добирает атакующий (opponentId)
                let deck = [...data.deck];
                while(hands[opponentId].length < 6 && deck.length > 0) {
                    hands[opponentId].push(deck.pop());
                }

                // Роли не меняются, атакующий снова атакует
                await updateDoc(gameRef, {
                    table: [],
                    hands: hands,
                    deck: deck,
                    turn: opponentId,
                    attacker: opponentId 
                });
            }
        }

        // --- UTILS ---
        
        function createDeck() {
            const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
            const ranks = ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
            const values = { '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
            let d = [];
            for (let s of suits) {
                for (let r of ranks) {
                    d.push({ suit: s, rank: r, value: values[r] });
                }
            }
            // Shuffle
            for (let i = d.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [d[i], d[j]] = [d[j], d[i]];
            }
            return d;
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.classList.remove('opacity-0');
            setTimeout(() => t.classList.add('opacity-0'), 2500);
        }

        window.copyId = () => {
            const id = document.getElementById('display-game-id').innerText;
            navigator.clipboard.writeText(id);
            showToast("ID скопирован");
        }
    </script>
</body>
</html>
