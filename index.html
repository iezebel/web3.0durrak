<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Durak Classic</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: #2a5c32;
            --card-width: 70px;
            --card-height: 100px;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            user-select: none;
        }

        /* --- СЧЕТ --- */
        .score-board {
            position: absolute;
            top: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 50;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
        .score-box {
            background: rgba(0, 0, 0, 0.4);
            padding: 5px 10px;
            border-radius: 10px;
        }

        /* Игровой стол */
        #game-area {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* КОЛОДА И КОЗЫРЬ (Вертикальный режим) */
        .deck-area {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
        }

        .trump-card-container {
            position: relative;
            width: var(--card-width);
            height: var(--card-height);
            /* УБРАЛИ ПОВОРОТ: карта стоит вертикально */
            transform: none; 
            z-index: 0;
            /* Сдвигаем немного вправо, чтобы колода её частично перекрывала, но значение было видно */
            margin-right: -25px; 
            box-shadow: -2px 2px 5px rgba(0,0,0,0.3);
            border-radius: 8px;
            background-color: #ddd; /* Чтобы отличалась, если рубашка не загрузится */
        }

        /* Внутренность козыря: обычное вертикальное отображение */
        .trump-inner-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            /* УБРАЛИ ПОВОРОТ ТЕКСТА */
            transform: none;
        }

        .trump-rank-text {
            font-size: 36px; /* Крупная цифра */
            font-weight: 900;
            line-height: 1;
        }
        
        .trump-suit-text {
            font-size: 32px; /* Крупная масть */
            line-height: 1;
            margin-top: 5px;
        }

        .deck-stack {
            background: #1a3c22;
            border: 2px solid #fff;
            border-radius: 8px;
            width: var(--card-width);
            height: var(--card-height);
            z-index: 10; /* Колода сверху */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background-image: repeating-linear-gradient(45deg, #1a3c22 0, #1a3c22 10px, #142e1a 10px, #142e1a 20px);
            box-shadow: -4px 0px 10px rgba(0,0,0,0.5); /* Тень слева, чтобы отделить от козыря */
        }

        /* Место для карт на столе */
        .table-slots {
            display: flex;
            gap: 10px;
            min-height: 120px;
            z-index: 10;
            padding: 0 10px;
            justify-content: center;
            flex-wrap: wrap;
            max-width: 100%;
        }

        .slot {
            width: var(--card-width);
            height: var(--card-height);
            position: relative;
        }

        .slot .card {
            position: absolute;
            top: 0;
            left: 0;
        }

        .slot .card.defending {
            top: 15px;
            left: 15px;
            transform: rotate(10deg);
            z-index: 2;
        }

        /* Руки игроков */
        .hand {
            display: flex;
            justify-content: center;
            padding: 10px;
            gap: -20px;
            height: 120px;
            width: 100%;
            box-sizing: border-box;
        }

        .bot-hand {
            position: absolute;
            top: 0;
            transform: rotate(180deg);
            pointer-events: none;
        }

        .player-hand {
            position: absolute;
            bottom: 60px;
            overflow-x: auto;
            padding-left: 30px; 
            padding-right: 30px;
        }

        /* Карта */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            background: white;
            border-radius: 8px;
            color: black;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px;
            box-sizing: border-box;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .card.red { color: #d40000; }
        .card.black { color: #000; }

        .card-back {
            background: #1a3c22;
            background-image: repeating-linear-gradient(45deg, #376340 0, #376340 10px, #2a5c32 10px, #2a5c32 20px);
            border: 2px solid white;
        }
        
        .card.selected {
            transform: translateY(-20px);
            border: 2px solid gold;
            box-shadow: 0 0 10px gold;
        }

        .card-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }

        /* Кнопки управления */
        .controls {
            position: absolute;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        button {
            background: #ffcc00;
            border: none;
            padding: 10px 30px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 4px #c29d00;
            cursor: pointer;
            transition: all 0.1s;
        }
        
        button:active {
            transform: translateY(4px);
            box-shadow: 0 0 #c29d00;
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        button.hidden { display: none; }
        button.take-btn { background: #ff4d4d; color: white; box-shadow: 0 4px #b30000; }
        
        .status-msg {
            position: absolute;
            top: 45%;
            width: 100%;
            text-align: center;
            font-size: 20px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s;
        }

        /* --- МОДАЛЬНОЕ ОКНО --- */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .modal.visible {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background: #2a5c32;
            border: 4px solid #ffcc00;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 80%;
        }

        .modal h2 { margin-top: 0; font-size: 24px; }
        .score-change { font-size: 22px; font-weight: bold; }
        .win-text { color: #5eff5e; }
        .loss-text { color: #ff5e5e; }

    </style>
</head>
<body>

    <!-- Счет -->
    <div class="score-board">
        <div class="score-box">Бот: <span id="score-bot">200</span></div>
        <div class="score-box">Вы: <span id="score-player">200</span></div>
    </div>

    <div id="game-area">
        <div class="hand bot-hand" id="bot-hand"></div>

        <div class="deck-area">
            <!-- Козырь теперь отрисовывается здесь -->
            <div id="trump-placeholder"></div>
            
            <div class="deck-stack" id="deck-count">36</div>
        </div>

        <div class="table-slots" id="table"></div>
        <div class="status-msg" id="status"></div>
        <div class="hand player-hand" id="player-hand"></div>

        <div class="controls">
            <button id="btn-action" onclick="playerAction()">Бито</button>
        </div>
    </div>

    <!-- Модальное окно -->
    <div id="game-over-modal" class="modal">
        <div class="modal-content">
            <h2 id="modal-title">Игра окончена</h2>
            <p id="modal-desc"></p>
            <div id="modal-points" class="score-change"></div>
            <br>
            <button onclick="restartGame()">Играть снова</button>
        </div>
    </div>

<script>
    const tg = window.Telegram.WebApp;
    tg.expand();

    // --- НАСТРОЙКИ ---
    const START_POINTS = 200;
    const BET_AMOUNT = 10;
    
    let playerScore = parseInt(localStorage.getItem('durak_player_score')) || START_POINTS;
    let botScore = parseInt(localStorage.getItem('durak_bot_score')) || START_POINTS;

    const SUITS = ['♠', '♣', '♦', '♥'];
    const RANKS = ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
    const VALUES = { '6':6, '7':7, '8':8, '9':9, '10':10, 'J':11, 'Q':12, 'K':13, 'A':14 };

    let deck = [];
    let playerHand = [];
    let botHand = [];
    let table = []; 
    let trumpSuit = '';
    let currentTrumpCard = null; 
    let isPlayerTurn = true; 
    let selectedCard = null;
    let gameActive = true;
    let isProcessing = false; 

    class Card {
        constructor(rank, suit) {
            this.rank = rank;
            this.suit = suit;
            this.id = Math.random().toString(36).substr(2, 9);
        }
        get value() { return VALUES[this.rank]; }
        get isRed() { return this.suit === '♦' || this.suit === '♥'; }
    }

    function initGame() {
        gameActive = true;
        isProcessing = false;
        playerHand = [];
        botHand = [];
        table = [];
        selectedCard = null;
        document.getElementById('game-over-modal').classList.remove('visible');
        updateScoreDisplay();

        // 1. Создаем колоду
        deck = [];
        for (let s of SUITS) {
            for (let r of RANKS) {
                deck.push(new Card(r, s));
            }
        }
        
        // 2. Мешаем
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        
        // 3. Козырь
        currentTrumpCard = deck[0]; 
        trumpSuit = currentTrumpCard.suit;

        fillHand(playerHand);
        fillHand(botHand);
        determineFirstTurn();
        renderGame();
        updateButton();
    }

    function fillHand(hand) {
        while (hand.length < 6 && deck.length > 0) {
            hand.push(deck.pop());
        }
        sortHand(hand);
    }

    function sortHand(hand) {
        hand.sort((a, b) => {
            const aVal = (a.suit === trumpSuit ? 20 : 0) + a.value;
            const bVal = (b.suit === trumpSuit ? 20 : 0) + b.value;
            return aVal - bVal;
        });
    }

    function determineFirstTurn() {
        let playerMinTrump = 100;
        let botMinTrump = 100;

        playerHand.forEach(c => {
            if (c.suit === trumpSuit && c.value < playerMinTrump) playerMinTrump = c.value;
        });
        botHand.forEach(c => {
            if (c.suit === trumpSuit && c.value < botMinTrump) botMinTrump = c.value;
        });

        if (playerMinTrump < botMinTrump) {
            isPlayerTurn = true;
            updateStatus("Ваш ход (младший козырь)");
        } else if (botMinTrump < playerMinTrump) {
            isPlayerTurn = false;
            updateStatus("Ход бота (младший козырь)");
            isProcessing = true;
            setTimeout(() => { isProcessing = false; botAttack(); }, 1000);
        } else {
            isPlayerTurn = true;
            updateStatus("Ваш ход");
        }
    }

    // --- РЕНДЕРИНГ ---

    function createCardEl(card, isFaceUp = true) {
        const el = document.createElement('div');
        el.className = `card ${isFaceUp ? (card.isRed ? 'red' : 'black') : 'card-back'}`;
        if (isFaceUp) {
            el.innerHTML = `
                <div style="font-size: 14px; line-height: 1;">${card.rank}</div>
                <div style="font-size: 14px; text-align: right; line-height: 1;">${card.suit}</div>
                <div class="card-center">${card.suit}</div>
            `;
            el.onclick = () => {
                if (!isProcessing) selectCard(card);
            };
        }
        return el;
    }

    function renderGame() {
        const botDiv = document.getElementById('bot-hand');
        botDiv.innerHTML = '';
        botHand.forEach(() => botDiv.appendChild(createCardEl(null, false)));

        const playerDiv = document.getElementById('player-hand');
        playerDiv.innerHTML = '';
        playerHand.forEach(card => {
            const el = createCardEl(card, true);
            if (selectedCard && selectedCard.id === card.id) el.classList.add('selected');
            playerDiv.appendChild(el);
        });

        const tableDiv = document.getElementById('table');
        tableDiv.innerHTML = '';
        table.forEach(pair => {
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.appendChild(createCardEl(pair.attack));
            if (pair.defend) {
                const defCard = createCardEl(pair.defend);
                defCard.classList.add('defending');
                slot.appendChild(defCard);
            }
            tableDiv.appendChild(slot);
        });

        // --- КОЗЫРЬ (РЕНДЕР) ---
        const trumpContainer = document.getElementById('trump-placeholder');
        trumpContainer.innerHTML = '';
        if (deck.length > 0) {
            const actualTrump = deck[0];
            
            // Создаем визуальный контейнер карты (ВЕРТИКАЛЬНЫЙ)
            const trumpEl = document.createElement('div');
            trumpEl.className = `card trump-card-container ${actualTrump.isRed ? 'red' : 'black'}`;
            
            // Внутрь вставляем текст (ПРЯМОЙ)
            trumpEl.innerHTML = `
                <div class="trump-inner-text">
                    <div class="trump-rank-text">${actualTrump.rank}</div>
                    <div class="trump-suit-text">${actualTrump.suit}</div>
                </div>
            `;
            trumpContainer.appendChild(trumpEl);
        }

        const deckCountEl = document.getElementById('deck-count');
        deckCountEl.innerText = deck.length > 0 ? deck.length : "";
        deckCountEl.style.display = deck.length > 0 ? 'flex' : 'none';
    }

    function updateStatus(msg) {
        const el = document.getElementById('status');
        el.innerText = msg;
        el.style.opacity = 1;
        if (el.hideTimeout) clearTimeout(el.hideTimeout);
        el.hideTimeout = setTimeout(() => el.style.opacity = 0, 3000);
    }

    function updateButton() {
        const btn = document.getElementById('btn-action');
        btn.disabled = isProcessing;

        if (isPlayerTurn) {
            if (table.length > 0) {
                const allCovered = table.every(p => p.defend != null);
                if (allCovered) {
                    btn.innerText = "Бито";
                    btn.classList.remove('hidden', 'take-btn');
                } else {
                    btn.classList.add('hidden'); 
                }
            } else {
                btn.classList.add('hidden');
            }
        } else {
            btn.innerText = "Взять";
            btn.classList.remove('hidden');
            btn.classList.add('take-btn');
        }
    }

    function updateScoreDisplay() {
        document.getElementById('score-player').innerText = playerScore;
        document.getElementById('score-bot').innerText = botScore;
        localStorage.setItem('durak_player_score', playerScore);
        localStorage.setItem('durak_bot_score', botScore);
    }

    // --- ЛОГИКА ИГРЫ ---

    function selectCard(card) {
        if (!gameActive || isProcessing) return;
        
        if (selectedCard && selectedCard.id === card.id) {
            playCard(card);
            selectedCard = null;
        } else {
            selectedCard = card;
        }
        renderGame();
    }

    function playCard(card) {
        if (isPlayerTurn) {
            if (table.length >= 6) {
                updateStatus("Максимум 6 карт на столе!");
                return;
            }
            if (table.length > 0) {
                const ranksOnTable = table.flatMap(p => [p.attack.rank, p.defend?.rank]).filter(r => r);
                if (!ranksOnTable.includes(card.rank)) {
                    updateStatus("Нельзя подкинуть этот ранг!");
                    return;
                }
            }
            const unansweredCount = table.filter(p => !p.defend).length;
            if (unansweredCount + 1 > botHand.length) {
                updateStatus("У бота не хватит карт!");
                return;
            }

            playerHand = playerHand.filter(c => c.id !== card.id);
            table.push({ attack: card, defend: null });
            renderGame();
            
            isProcessing = true;
            updateButton();
            setTimeout(() => {
                isProcessing = false;
                botDefend();
            }, 1000);

        } else {
            const pairIndex = table.findIndex(p => p.defend === null);
            if (pairIndex === -1) return; 

            const attackCard = table[pairIndex].attack;
            if (canBeat(card, attackCard)) {
                playerHand = playerHand.filter(c => c.id !== card.id);
                table[pairIndex].defend = card;
                renderGame();
                if (table.every(p => p.defend)) {
                    updateStatus("Ждем подкинет ли бот...");
                    isProcessing = true;
                    updateButton();
                    setTimeout(() => {
                        isProcessing = false;
                        botAttackThrowIn();
                    }, 1000);
                }
            } else {
                updateStatus("Этой картой не отбиться!");
            }
        }
    }

    function canBeat(card, target) {
        if (card.suit === target.suit) {
            return card.value > target.value;
        }
        return card.suit === trumpSuit;
    }

    function playerAction() {
        if (isProcessing) return; 
        if (isPlayerTurn) {
            endTurn(true);
        } else {
            table.forEach(p => {
                playerHand.push(p.attack);
                if (p.defend) playerHand.push(p.defend);
            });
            sortHand(playerHand);
            table = [];
            endTurn(false);
        }
    }

    function botDefend() {
        const pairIndex = table.findIndex(p => p.defend === null);
        if (pairIndex === -1) return;

        const attack = table[pairIndex].attack;
        let candidates = botHand.filter(c => canBeat(c, attack));
        
        if (candidates.length > 0) {
            candidates.sort((a, b) => {
                const aTrump = a.suit === trumpSuit;
                const bTrump = b.suit === trumpSuit;
                if (aTrump && !bTrump) return 1; 
                if (!aTrump && bTrump) return -1;
                return a.value - b.value;
            });

            const bestCard = candidates[0];
            botHand = botHand.filter(c => c.id !== bestCard.id);
            table[pairIndex].defend = bestCard;
            
            updateStatus("Бот отбился");
            renderGame();
            updateButton(); 
        } else {
            updateStatus("Бот берет!");
            isProcessing = true;
            setTimeout(() => {
                table.forEach(p => {
                    botHand.push(p.attack);
                    if (p.defend) botHand.push(p.defend);
                });
                sortHand(botHand);
                table = [];
                replenishHands(true); 
                if (checkWin()) return;
                isPlayerTurn = true;
                updateStatus("Ваш ход (Бот взял)");
                isProcessing = false;
                renderGame();
                updateButton();
            }, 1500);
        }
    }

    function botAttack() {
        if (!gameActive) return;
        botHand.sort((a, b) => {
            const aTrump = a.suit === trumpSuit;
            const bTrump = b.suit === trumpSuit;
            if (aTrump && !bTrump) return 1;
            if (!aTrump && bTrump) return -1;
            return a.value - b.value;
        });

        const card = botHand[0];
        botHand = botHand.filter(c => c.id !== card.id);
        table.push({ attack: card, defend: null });
        renderGame();
        updateStatus("Бот атакует");
        updateButton(); 
    }

    function botAttackThrowIn() {
        if (!gameActive) return;
        if (table.length >= 6) {
            botSaysBito();
            return;
        }
        const ranksOnTable = table.flatMap(p => [p.attack.rank, p.defend?.rank]).filter(r => r);
        let candidates = botHand.filter(c => ranksOnTable.includes(c.rank));

        if (candidates.length > 0 && playerHand.length > 0) {
            candidates.sort((a, b) => (a.suit === trumpSuit ? 100 : 0) + a.value - ((b.suit === trumpSuit ? 100 : 0) + b.value));
            const card = candidates[0];
            botHand = botHand.filter(c => c.id !== card.id);
            table.push({ attack: card, defend: null });
            updateStatus("Бот подкидывает!");
            renderGame();
            updateButton(); 
        } else {
            botSaysBito();
        }
    }

    function botSaysBito() {
        updateStatus("Бот: Бито.");
        isProcessing = true;
        setTimeout(() => {
            isProcessing = false;
            endTurn(true);
        }, 1000);
    }

    function endTurn(success) {
        table = [];
        renderGame();
        if (checkWin()) return;

        if (isPlayerTurn) {
            replenishHands(true); 
            isPlayerTurn = false;
            updateStatus("Ход Бота");
            updateButton();
            isProcessing = true;
            setTimeout(() => {
                isProcessing = false;
                botAttack();
            }, 1000);
        } else {
            if (success) {
                replenishHands(false); 
                isPlayerTurn = true;
                updateStatus("Ваш ход");
            } else {
                replenishHands(false);
                isPlayerTurn = false;
                updateStatus("Вы взяли. Ход бота");
                isProcessing = true;
                setTimeout(() => {
                    isProcessing = false;
                    botAttack();
                }, 1000);
            }
        }
        renderGame();
        updateButton();
    }

    function replenishHands(playerAttackedFirst) {
        if (playerAttackedFirst) {
            fillHand(playerHand);
            fillHand(botHand);
        } else {
            fillHand(botHand);
            fillHand(playerHand);
        }
    }

    function checkWin() {
        if (deck.length === 0) {
            if (playerHand.length === 0) {
                gameOver('player');
                return true;
            }
            if (botHand.length === 0) {
                gameOver('bot');
                return true;
            }
        }
        return false;
    }

    function restartGame() {
        initGame();
    }

    function gameOver(winner) {
        gameActive = false;
        const titleEl = document.getElementById('modal-title');
        const descEl = document.getElementById('modal-desc');
        const pointsEl = document.getElementById('modal-points');

        if (winner === 'player') {
            playerScore += BET_AMOUNT;
            botScore -= BET_AMOUNT;
            titleEl.innerText = "ПОБЕДА!";
            titleEl.className = "win-text";
            descEl.innerText = "Карты кончились, вы вышли.";
            pointsEl.innerText = `+${BET_AMOUNT}`;
            pointsEl.className = "score-change win-text";
        } else {
            playerScore -= BET_AMOUNT;
            botScore += BET_AMOUNT;
            titleEl.innerText = "ПОРАЖЕНИЕ";
            titleEl.className = "loss-text";
            descEl.innerText = "У бота кончились карты раньше.";
            pointsEl.innerText = `-${BET_AMOUNT}`;
            pointsEl.className = "score-change loss-text";
        }
        updateScoreDisplay();
        document.getElementById('game-over-modal').classList.add('visible');
    }

    initGame();

</script>
</body>
</html>

